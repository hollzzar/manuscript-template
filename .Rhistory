knitr::include_graphics("images/rendering_process.png")
knitr::include_graphics("images/rendering_process.png")
# This is a chunk of R code that adds an image
knitr::include_graphics("images/example_chunk.png")
devtools::install_github('yihui/tinytex')
install.packages("devtools")
devtools::install_github('yihui/tinytex')
tinytex::reinstall_tinytex()
tinytex::pdflatex('test.tex')
tinytex::install_tinytex()
tinytex::install_tinytex()
update.packages(ask = FALSE, checkBuilt = TRUE)
tinytex::tlmgr_update()
tinytex::reinstall_tinytex()
tinytex::pdflatex('test.tex')
tinytex::pdflatex('test.tex')
devtools::install_github("mitchelloharawild/vitae")
getwd()
setwd("~/Mirror/manuscript-template/sections/code")
# Package list
pkg_list <- c("plyr","tidyverse", "data.table", "ggplot2", "kableExtra")
# Load packages
pacman::p_load(pkg_list, character.only = TRUE)
## Create scatter plot ##
# Save number of cylinders (cyl) as factor
# Otherwise, ggplot will treat it as a continuous variable
mtcars <- mtcars %>%
mutate(cyl = as.factor(cyl))
# Create scatter plot
mtcars_scatter <- ggplot(mtcars) +
geom_jitter(aes(mpg, wt, color = cyl)) +
geom_smooth(formula = y ~ x, aes(mpg, wt), method = "lm", se = TRUE, level = 0.95,
fill = "#d7d8db", color = "black", size = 0.5) +
scale_y_continuous(expand = c(0,0), limits = c(0,6)) +
scale_x_continuous(expand = c(0,0), limits = c(10,35)) +
scale_color_brewer(type = "qual", palette = "Paired") +
theme_classic() +
labs(title = "Miles per gallon and vehicle weight are negatively correlated",
y = "Vehicle weight (1000 lbs)",
x = "Miles per gallon",
color = "Cylinders")
# Save scatter plot
ggsave("test_graph.png", plot = mtcars_scatter, width = 3, height = 3, units = "in")
# Save scatter plot
ggsave("test_graph.png", plot = mtcars_scatter, width = 6, height = 3, units = "in")
# Create scatter plot
mtcars_scatter <- ggplot(mtcars) +
geom_smooth(formula = y ~ x, aes(mpg, wt), method = "lm", se = TRUE, level = 0.95,
fill = "#d7d8db", color = "black", size = 0.5) +
geom_jitter(aes(mpg, wt, color = cyl)) +
scale_y_continuous(expand = c(0,0), limits = c(0,6)) +
scale_x_continuous(expand = c(0,0), limits = c(10,35)) +
scale_color_brewer(type = "qual", palette = "Paired") +
theme_classic() +
labs(title = "Miles per gallon and vehicle weight are negatively correlated",
y = "Vehicle weight (1000 lbs)",
x = "Miles per gallon",
color = "Cylinders") +
theme(text=element_text(family = "LM Roman 10"))
# Save scatter plot
ggsave("test_graph.png", plot = mtcars_scatter, width = 6, height = 3, units = "in")
wd <- getwd()
source(paste(wd, "scripts/source_script.R", sep = "/"))
# Pull car model names from row names into new column
mtcars_mod <- mtcars %>%
tibble::rownames_to_column(var = "models")
# Count number of unique model names
total_pars <- mtcars_mod %>% pull(models) %>% unique() %>% length()
# Summarize data for table
test_mt <- mtcars_mod %>%
group_by(cyl) %>%
dplyr::summarize(`Miles per gallon` = mean(mpg), `Horse power` = mean(hp), Weight = mean(wt), .groups = "keep") %>%
rename(`Number of cylinders` = cyl)
test_mean <- mtcars_mod %>% pull(wt) %>% mean()
test_sd <- mtcars_mod %>% pull(wt) %>% sd()
lm(wt ~ mpg, mtcars_mod)
# Run correlation between mpg and wt
mt_corr <- cor.test(x = mpg, y = wt, method = "pearson", data = mtcars_mod)
View(mtcars_mod)
# Run correlation between mpg and wt
mt_corr <- cor.test(wt ~ mpg, method = "pearson", data = mtcars_mod)
# Run correlation between mpg and wt
mt_corr <- cor.test(~ wt + mpg, method = "pearson", data = mtcars_mod)
View(test_mt)
View(mt_corr)
cor.test(~ wt + mpg, method = "pearson", data = mtcars_mod)
p_formatting <- function(val, format_code = 1) {
# If I want to include the symbol (when I'm calling this variable in text)
if (format_code == 1) {
# If the p value is less than .001, get the less than symbol
# Otherwise, get the equals symbol
sign_type <- if_else(val < 0.001, "<", "=")
# If the p value is less than .001, set the value equal to .001
if (sign_type == "<") {
val <- ".001"
# Otherwise, get the actual p value,
# round it to three decimal places, and
# remove the leading zero
} else {
val <- sprintf("%.3f", val)
val <- substring(val, 2)
}
# Combine the new/formatted p value with < or =,
# depending on the p value
val_string <- paste(sign_type, val, sep = " ")
val_string
# If I don't want the symbol (as in a table),
# just round the value to three decimal places
# and remove the leading zero
} else if (format_code == 0) {
val <- sprintf("%.3f", val)
val_string <- substring(val, 2)
val_string
}
}
# Make number formatting function for t and F values
stat_formatting <- function(val) {
val <- abs(val)
val <- sprintf("%.2f", val)
val
}
# Make number formatting function for integers (e.g., reaction times in ms)
zero_formatting <- function(val) {
val <- sprintf("%.0f", val)
val
}
# Make number formatting function for percentages
pct_formatting <- function(val) {
val <- val %>%
prod(100) %>%
sprintf("%.2f", .) %>%
paste0("%")
val
}
# Make number formatting function for degrees of freedom
df_formatting <- function(val) {
val <- if_else(val%%1 == 0, sprintf("%.0f", val), sprintf("%.2f", val))
val
}
# Make function to output APA formatting
# Use with numbers already passed through df_, stat_, and p_formatting
apa_formatting <- function(df, stat_val, p_val) {
# Check if there are two df values (for an F statistic)
# Or just one df value (for a t statistic)
df <- c(df)
# Format based on whether it's an F or t statistic
if (length(df) == 2) {
sprintf("*F*(%s, %s) = %s, *p* %s", df[1], df[2], stat_val, p_val)
} else {
sprintf("*t*(%s) = %s, *p* %s", df, stat_val, p_val)
}
}
# General number formatting
# Round to two decimal places, keep trailing zeros
num_formatting <- function(val) {
val <- sprintf("%.2f", val)
val_string <- substring(val, 2)
val_string
}
# Format values
mt_t <- stat_formatting(mt_corr$statistic)
mt_df <- df_formatting(mt_corr$parameter)
mt_p <- p_formatting(mt_corr$p.value, format_code = 1)
mt_apa <- apa_formatting(mt_df, mt_t, mt_p)
# Format correlation value
mt_r <- num_formatting(mt_corr$estimate)
mt_corr$estimate
sprintf("%.2f", mt_corr$estimate)
sprintf("%.2f", -0.1)
substring(sprintf("%.2f", mt_corr$estimate))
substring(sprintf("%.2f", mt_corr$estimate),2)
sprintf("%.2f", 0.1)
# Make number formatting function for t and F values
stat_formatting <- function(val) {
sprintf("%.2f", abs(val))
}
# Make number formatting function for integers (e.g., reaction times in ms)
zero_formatting <- function(val) {
sprintf("%.0f", val)
}
# Make number formatting function for percentages
pct_formatting <- function(val) {
val %>% prod(100) %>% sprintf("%.2f", .) %>% paste0("%")
}
# Make number formatting function for degrees of freedom
df_formatting <- function(val) {
if_else(val%%1 == 0, sprintf("%.0f", val), sprintf("%.2f", val))
}
# Make function to output APA formatting
# Use with numbers already passed through df_, stat_, and p_formatting
apa_formatting <- function(df, stat_val, p_val) {
# Check if there are two df values (for an F statistic)
# Or just one df value (for a t statistic)
df <- c(df)
# Format based on whether it's an F or t statistic
if (length(df) == 2) {
sprintf("*F*(%s, %s) = %s, *p* %s", df[1], df[2], stat_val, p_val)
} else {
sprintf("*t*(%s) = %s, *p* %s", df, stat_val, p_val)
}
}
# General number formatting
# Round to two decimal places, keep trailing zeros
# Include negative sign if less than zero
num_formatting <- function(val) {
sprintf("%.2f", val)
}
# Run correlation between mpg and wt
mt_corr <- cor.test(~ wt + mpg, method = "pearson", data = mtcars_mod)
# Format statistics
# Normally when I have a whole table full of ANOVA outputs, I would use mutate
# to format entire columns
mt_t <- stat_formatting(mt_corr$statistic)
mt_df <- df_formatting(mt_corr$parameter)
mt_p <- p_formatting(mt_corr$p.value, format_code = 1)
mt_apa <- apa_formatting(mt_df, mt_t, mt_p)
# Format correlation value
mt_r <- num_formatting(mt_corr$estimate)
# Make function to output APA formatting for t and F statistics
# Use with numbers already passed through df_, stat_, and p_formatting
apa_stat <- function(df, stat_val, p_val) {
# Check if there are two df values (for an F statistic)
# Or just one df value (for a t statistic)
df <- c(df)
# Format based on whether it's an F or t statistic
if (length(df) == 2) {
sprintf("*F*(%s, %s) = %s, *p* %s", df[1], df[2], stat_val, p_val)
} else {
sprintf("*t*(%s) = %s, *p* %s", df, stat_val, p_val)
}
}
# Make function to output APA formatting for t and F statistics
# Use with numbers already passed through df_, num_, and p_formatting
apa_corr <- function(df, corr_val, p_val) {
sprintf("*r*(%s) = %s, *p* %s", df, corr_val, p_val)
}
mt_r <- num_formatting(mt_corr$estimate)
mt_df <- df_formatting(mt_corr$parameter)
mt_p <- p_formatting(mt_corr$p.value, format_code = 1)
mt_apa <- apa_corr(mt_df, mt_r, mt_p)
# Pull mean and SD for weight variable
test_mean <- mtcars_mod %>% pull(wt) %>% mean()*1000 %>% zero_formatting()
# Pull mean and SD for weight variable
test_mean <- mtcars_mod %>% pull(wt) %>% mean()*1000
zero_formatting(test_mean)
# Pull mean and SD for weight variable
test_mean <- mtcars_mod %>% pull(wt) %>% zero_formatting(mean(.)*1000)
# Pull mean and SD for weight variable
test_mean <- mtcars_mod %>% pull(wt) %>% mean()*1000
# Pull mean and SD for weight variable
test_mean <- mtcars_mod %>% pull(wt) %>% (mean()*1000) %>% zero_formatting()
# Pull mean and SD for weight variable
test_mean <- mtcars_mod %>% pull(wt) %>% mean() %>% zero_formatting()
# Pull mean and SD for weight variable
test_mean <- mtcars_mod %>% pull(wt) %>% mean() %>% zero_formatting(.*1000)
# Pull mean and SD for weight variable
test_mean <- mtcars_mod %>% pull(wt*1000) %>% mean() %>% zero_formatting()
# Pull mean and SD for weight variable
test_mean <- mtcars_mod %>% pull(wt) %>% mean() %>% prod(1000) %>% zero_formatting()
rmarkdown::pandoc_convert("manuscript_template.tex", to = "word")
rmarkdown::pandoc_convert("manuscript_template.tex", to = "docx")
setwd("~Mirror/manuscript-template")
setwd("~/Mirror/manuscript-template")
rmarkdown::pandoc_convert("manuscript_template.tex", to = "docx")
rmarkdown::pandoc_convert("manuscript_template.tex", to = "docx")
rmarkdown::pandoc_convert("manuscript_template.tex", to = "html")
rmarkdown::pandoc_convert("manuscript_template.tex", to = "docx", output = "test.docx")
